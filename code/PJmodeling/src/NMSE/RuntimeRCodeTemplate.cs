// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 17.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace NMSE
{
    using System.Globalization;
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "H:\gabo\novartis\20241015-1330h-Novartis-Markov\Novartis-Markov\NMSE\NMSE\RuntimeRCodeTemplate.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    public partial class RuntimeRCodeTemplate : RuntimeRCodeTemplateBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("\r\n# Generated with Novartis Markov Simulation Engine (NMSE)\r\n# Version: ");
            
            #line 9 "H:\gabo\novartis\20241015-1330h-Novartis-Markov\Novartis-Markov\NMSE\NMSE\RuntimeRCodeTemplate.tt"
 
            
            #line default
            #line hidden
            this.Write("#\r\n# Project Title: ");
            
            #line 11 "H:\gabo\novartis\20241015-1330h-Novartis-Markov\Novartis-Markov\NMSE\NMSE\RuntimeRCodeTemplate.tt"
 
            
            #line default
            #line hidden
            this.Write("# Authors: ");
            
            #line 12 "H:\gabo\novartis\20241015-1330h-Novartis-Markov\Novartis-Markov\NMSE\NMSE\RuntimeRCodeTemplate.tt"
 
            
            #line default
            #line hidden
            this.Write("# Description: ");
            
            #line 13 "H:\gabo\novartis\20241015-1330h-Novartis-Markov\Novartis-Markov\NMSE\NMSE\RuntimeRCodeTemplate.tt"
 
            
            #line default
            #line hidden
            this.Write("# Date of creation: ");
            
            #line 14 "H:\gabo\novartis\20241015-1330h-Novartis-Markov\Novartis-Markov\NMSE\NMSE\RuntimeRCodeTemplate.tt"
 WriteLine(DateTime.Now.ToString("yyyy-MM-dd_hhmm").ToString(CultureInfo.InvariantCulture)); 
            
            #line default
            #line hidden
            this.Write("\r\n\r\n# Set working directory\r\n\r\nsetwd (\".\")\r\n\r\n# Load libraries\r\n\r\n#library(Matrix" +
                    ")    # GPL3 Licence\r\nlibrary(stats)      # Base\r\nlibrary(base)       #? Wird es " +
                    "im Code verwendet?\r\nlibrary(readxl)     # MIT Licence --> Closed Source verwendb" +
                    "ar \r\nlibrary(ggplot2)    # MIT Licence --> Closed Source verwendbar\r\nlibrary(mat" +
                    "rixdist) # GPL3 Licence\r\nlibrary(tidyverse)  # OK\r\nlibrary(writexl)    # OK\r\nlib" +
                    "rary(expm)       # GPL3 Licence\r\nlibrary(trustOptim) # ???\r\nlibrary(pracma)     " +
                    "# ???\r\n\r\n## ####################################################################" +
                    "#####  ##\r\n# function 1: recalculate_main_diagonal \r\n# \r\n# step 1: All main diag" +
                    "onal elements are set to 0\r\n# step 2: For each row the main diagonal is set so t" +
                    "hat row sum adds up to 1\r\n# -- validated --\r\n## ################################" +
                    "########################################## ##\r\n\r\nrecalculate_main_diagonal <- fu" +
                    "nction(rawMatrix)\r\n{\r\nfor (k in 1:nrow(rawMatrix)) {\r\n  rawMatrix[k, k] <- 0\r\n  " +
                    "rawMatrix[k, k] <- 1 - sum(rawMatrix[k, ])\r\n}\r\nreturn(rawMatrix)\r\n}\r\n\r\n#########" +
                    "#################################################################### ##\r\n# funct" +
                    "ion 2: check_matrix_row_sum\r\n# \r\n# step 1: Check whether each row sum is 1.\r\n# s" +
                    "tep 2: Return (Failure if not)\r\n# -- validated --\r\n#############################" +
                    "################################################ ##\r\n\r\n\r\ncheck_matrix_row_sum <-" +
                    " function(rawMatrix)\r\n{\r\n  for (k in 1:nrow(rawMatrix)) {\r\n    if (sum(rawMatrix" +
                    "[k, ]) != 1) {\r\n    cat(\"Probabilities in row\", k, \"!= 1 - Value:\", sum(rawMatri" +
                    "x[k, ]), \"\\n\")\r\n    return(FALSE)\r\n  } else {return(TRUE)}\r\n  }\r\n}\r\n\r\n##########" +
                    "################################################################### ##\r\n# functi" +
                    "on 3: model_diseasestates\r\n#\r\n# step 1: Define Transition States\r\n# step 2: calc" +
                    "ulate timeevol\r\n# step 3: return timeevol\r\n#\r\n##################################" +
                    "########################################## ##\r\n\r\nmodel_diseasestates <- function" +
                    "(variables) {\r\n\r\n# step 1:\r\n# u: uncontrolled; c: controlled; s: symptom-free\r\n " +
                    " \r\n  uu <- variables[1]\r\n  uc <- variables[2]\r\n  us <- variables[3]\r\n  cu <- var" +
                    "iables[4]\r\n  cc <- variables[5]\r\n  cs <- variables[6]\r\n  su <- variables[7]\r\n  s" +
                    "c <- variables[8]\r\n  ss <- variables[9]\r\n  \r\n  transMatrix <- base::matrix(c(uu," +
                    " uc, us, cu, cc, cs, su, sc, ss), nrow = 3, ncol = 3, byrow = TRUE)\r\n  \r\n  # pri" +
                    "nt(transMatrix)\r\n  # Normalization of Matrix transMatrix\r\n  \r\n  # transMatrix_no" +
                    "rm <- base::prop.table(transMatrix, margin = 1)\r\n  # transMatrix_norm2 <- normal" +
                    "ize_rows_l1(transMatrix)\r\n  # \r\n  # print(transMatrix_norm)\r\n  # print(transMatr" +
                    "ix_norm2)\r\n \r\n  initialState <- c(0.614, 0.3088, 0.0772)  #todo initial state no" +
                    "t hard coded in function \r\n  \r\n  timeevol <- initialState\r\n  \r\n  for (k in 1:num" +
                    "ber_of_cycles_t) {\r\n    #  Original Version\r\n    timeevol <- c(timeevol, as.vect" +
                    "or(initialState %*% matrixdist::matrix_power(k, transMatrix)))\r\n    \r\n    # tran" +
                    "sposed version of initialState\r\n    # timeevol <- c(timeevol, as.vector(t(initia" +
                    "lState) %*% matrixdist::matrix_power(k, transMatrix_norm)))\r\n    # expm Version\r" +
                    "\n    # timeevol <- c(timeevol, as.vector(initialState %*% (transMatrix_norm2 %^%" +
                    " k)))   \r\n      }\r\n  \r\n  #timeevol_56 <- timeevol\r\n  # print(timeevol_56)\r\n  tim" +
                    "eevol <- base::matrix(timeevol, nrow = k + 1, ncol = length(initialState), byrow" +
                    " = TRUE)\r\n  return(timeevol)\r\n}\r\n\r\n#############################################" +
                    "################################# ##\r\n# function 4: Residual function\r\n#\r\n# step" +
                    " 1: Calculate sum of squared deviations of estimated to hypothetical values  \r\n#" +
                    " step 2: Return sum of squared deviations\r\n#\r\n##################################" +
                    "############################################ ##\r\n\r\n# Residual function\r\n\r\nresidu" +
                    "al <- function(variables) {\r\n  data <- df_diseasestates_input[1:number_of_cycles" +
                    "_t, ]\r\n  return(sum((data - model_diseasestates(variables))^2))\r\n}\r\n\r\n##########" +
                    "#################################################################### ##\r\n#  \r\n# " +
                    "function 5: timeseries_prob\r\n# \r\n# step 1: dynamic imputation in column 9 for ro" +
                    "ws 1 to 8\r\n# step 2: call \"function 1: recalculate_main_diagonal\"\r\n#\r\n# -- valid" +
                    "ated --\r\n#######################################################################" +
                    "####### ##\r\n\r\ntimeseries_prob <- function(transMatrix, x0, timelength) {\r\n  n_st" +
                    "ates <- length(x0)\r\n  result <- matrix(0, nrow = timelength, ncol = n_states)\r\n " +
                    " x_k <- x0 #todo sprechender Name für x_k\r\n  result[1, ] <- x_k\r\n  \r\n  for (k in" +
                    " 2:timelength) {\r\n    if (k < 1000) {\r\n      transMatrix[1:8, 9] <- remission_pr" +
                    "ob[k, ]            # step 1: dynamic imputation in column 9 for rows 1 to 8\r\n   " +
                    "   transMatrix <- recalculate_main_diagonal(transMatrix) # step 2\r\n    }\r\n    x_" +
                    "k <- x_k %*% transMatrix\r\n    result[k, ] <- x_k\r\n  }\r\n  return(result)\r\n}\r\n\r\n# " +
                    "Code zum Testen der Funktion\r\n# x0 <- c(1, 0, 0, 0, 0, 0, 0, 0, 0)\r\n# timelength" +
                    " <- 8000\r\n# t <- timeseries_prob(transMatrix, x0, timelength)\r\n# t (8000 Zeilen " +
                    "9 Spalten)\r\n# function timeseries_MC_vec has been removed here.\r\n\r\n#############" +
                    "################################################################# ##\r\n#         " +
                    "                                 \r\n#  function 6: steadystate_MC              \r\n" +
                    "#  Steady state from Monte Carlo           \r\n#  function: steadystate_MC        " +
                    "       \r\n#\r\n#  -- not yet validated --                                         \r" +
                    "\n############################################################################# #" +
                    "#\r\n\r\n steadystate_MC <- function(transMatrix, x0, timelength, n_patients, simula" +
                    "tioncycles) {\r\n  result <- matrix(0, nrow = ((simulationcycles+1) * timelength)," +
                    " ncol = length(x0)) # leere Matrix mit 24.000 Zeilen erwartet waren 16.000\r\n  t " +
                    "<- timeseries_prob(transMatrix, x0, timelength)\r\n  \r\n  for (k in 1:((simulationc" +
                    "ycles * timelength))) {\r\n    result[k:(k + timelength - 1), ] <- result[k:(k + t" +
                    "imelength - 1), ] + t\r\n    result[(k + timelength):nrow(result), ] <- result[(k " +
                    "+ timelength):nrow(result), ] + t[nrow(t), ] #dasselbe aber ergänze den wert aus" +
                    " der letzten Zeile von t\r\n  }\r\n  \r\n  return(result[1:k, ])\r\n}\r\n\r\n# Alternative\r\n" +
                    "\r\n#steadystate_MC <- function(transMatrix, x0, timelength, n_patients, simulatio" +
                    "ncycles) {\r\n#  result <- matrix(0, nrow = (simulationcycles + 1) * timelength, n" +
                    "col = length(x0))\r\n#  t <- timeseries_prob(transMatrix, x0, timelength)\r\n#  for " +
                    "(k in 1:(simulationcycles * timelength)) {\r\n#    result[k:(k + timelength), ] <-" +
                    " result[k:(k + timelength), ] + t\r\n#    result[(k + timelength + 1):nrow(result)" +
                    ", ] <- result[(k + timelength + 1):nrow(result), ] + t[nrow(t), ]\r\n#  }\r\n#  retu" +
                    "rn(list(result[1:k, ], t))\r\n#}\r\n\r\n\r\n# function test code\r\n#\r\n# x0 <- c(1, 0, 0, " +
                    "0, 0, 0, 0, 0, 0)\r\n# timelength <- 8000\r\n# n_patients <- 10\r\n# simulationcycles " +
                    "<- 2\r\n# steadystate_MC (transMatrix, x0, timelength, n_patients, simulationcycle" +
                    "s)\r\n# xxx1 <- matrix(0, nrow = ((simulationcycles) * timelength), ncol = length(" +
                    "x0))\r\n# xxx1\r\n\r\n\r\n##############################################################" +
                    "############### ##\r\n#\r\n#  function 7: get_steadystate\r\n#  Calculate steady state" +
                    "\r\n#  Function: get_steadystate\r\n#\r\n#############################################" +
                    "################################ ##\r\n\r\n#todo parametrisieren --> Parameter event" +
                    "uell aus der Funktion ziehen und Werte global steuern. \r\n\r\nget_steadystate <- fu" +
                    "nction(transMatrix) {\r\n  x0 <- c(1, 0, 0, 0, 0, 0, 0, 0, 0)\r\n  timelength <- 800" +
                    "0\r\n  n_patients <- 10\r\n  simulationcycles <- 1\r\n  result <- steadystate_MC(trans" +
                    "Matrix, x0, timelength, n_patients, simulationcycles) # call function steadystat" +
                    "e_MC\r\n  normvec <- apply(result, 1, sum)\r\n  result_norm <- result / matrix(normv" +
                    "ec, nrow = length(normvec), ncol = ncol(result), byrow = TRUE)\r\n  result_norm_no" +
                    "remission <- result_norm[nrow(result_norm), 1:8] / sum(result_norm[nrow(result_n" +
                    "orm), 1:8]) * 100\r\n  return(result_norm_noremission) \r\n}\r\n\r\n####################" +
                    "######################################################### ##\r\n#\r\n#  function 8: " +
                    "reshape_steadystate_variables\r\n#  step 1: calculate mean_UCT\r\n#  step 2: calcula" +
                    "te share_highUCT\r\n#  step 3: define steadystate_df & colnames\r\n#  step 4: reduce" +
                    " number of states by group aggregation\r\n#\r\n#####################################" +
                    "######################################## ##\r\n\r\n# Derive output variables\r\n\r\nresh" +
                    "ape_steadystate_variables <- function(steadystate, states, UCTMatrix, cutoff_hig" +
                    "hUCT) {\r\n  mean_UCT <- sum(steadystate / 100 * UCTMatrix[1, 1:9])\r\n  share_highU" +
                    "CT <- sum((UCTMatrix[1, 1:9] >= cutoff_highUCT) * steadystate)\r\n  steadystate_df" +
                    " <- as.data.frame(matrix(steadystate, nrow = 1, ncol = 9, byrow = TRUE))\r\n  coln" +
                    "ames(steadystate_df) <- states[1:9]\r\n  aggregated_states_df <- data.frame(\r\n    " +
                    "Symptomatic = steadystate_df$Symptomatic + steadystate_df$No_diagnosis_virt,\r\n  " +
                    "  Diagnosed = steadystate_df$Diagnosed + steadystate_df$No_treatment_virt + stea" +
                    "dystate_df$Treatment_start,\r\n    Treated_uncontrolled = steadystate_df$Uncontrol" +
                    "led,\r\n    Treated_controlled = steadystate_df$Controlled,\r\n    Treated_symptom_f" +
                    "ree = steadystate_df$Symptom_free\r\n  )\r\n  return(list(mean_UCT = mean_UCT, share" +
                    "_highUCT = share_highUCT, aggregated_states_df = aggregated_states_df))\r\n}\r\n\r\n##" +
                    "########################################################################### ##\r\n" +
                    "\r\n\r\n\r\nsessionInfo() # \r\n\r\n# Measure for run time: start_time\r\nstart_runtime <- S" +
                    "ys.time()\r\n\r\n# Parameter List\r\n\r\npath_figures_folder <- \"figures\" \r\npath_data_fo" +
                    "lder <- \"data\"\r\n\r\ndir.create(path_figures_folder, showWarnings = FALSE)\r\ndir.cre" +
                    "ate(path_data_folder, showWarnings = FALSE)\r\n\r\npath_source_file       <- \"202301" +
                    "17_Urticaria Markov Transition Rates_v07.xlsx\"\r\nexcel_sheet_name_rates <- \"Expor" +
                    "t_rates\"\r\nexcel_sheet_name_uct   <- \"Export_UCT\"\r\nexcel_statesfitting   <- \"Expo" +
                    "rt_statesfitting\"\r\nexcel_remission   <- \"Export_remission\"\r\n\r\n\r\n## Parameters fo" +
                    "r model ############################################\r\n\r\n# Fit disease states\r\nnu" +
                    "mber_of_cycles_t <- 99 #adjustable\r\n\r\n# Matrix with States for each week \r\nstate" +
                    "s_to_fit <- matrix(0, nrow = number_of_cycles_t, ncol = 3)\r\nt_vec <- c(6, 18, 30" +
                    ") ## week of interventions\r\nt_vec <- t_vec - 5  ## Adjustment?\r\n\r\nlast_elem <- t" +
                    "ail(t_vec, n = 1)  # Get the last element of t_vec\r\nadditional_values <- seq(fro" +
                    "m = last_elem + 1, to = number_of_cycles_t, by = 10)\r\nt_vec_new <- c(t_vec, addi" +
                    "tional_values)\r\n\r\n# Define values for transition matrix\r\nvalues_to_assign <- mat" +
                    "rix(c(0.614, 0.3088, 0.0772,\r\n                             0.1842, 0.65264, 0.16" +
                    "316,\r\n                             0.05526, 0.65264, 0.2921), ncol = 3, byrow = " +
                    "TRUE)\r\n\r\n# values_to_assign\r\n# Assign values to specific rows in states_to_fit m" +
                    "atrix\r\n\r\n# row then column\r\n\r\nfor (targetrow in 1:number_of_cycles_t)\r\n     {\r\n " +
                    " if (targetrow == t_vec[1]) {\r\n    states_to_fit[targetrow,] <- values_to_assign" +
                    "[1,]\r\n  }\r\n  else if (targetrow < t_vec[2])\r\n  {\r\n    states_to_fit[targetrow,] " +
                    "<- c(0,0,0)\r\n  }\r\n  else if (targetrow == t_vec[2])\r\n  {\r\n    states_to_fit[targ" +
                    "etrow,] <- values_to_assign[2,]\r\n  }\r\n  else if (targetrow < t_vec[3])\r\n  {\r\n   " +
                    " states_to_fit[targetrow,] <- c(0,0,0)\r\n  }\r\n  else {\r\n    states_to_fit[targetr" +
                    "ow,] <- values_to_assign[3,]\r\n  }\r\n  }\r\n\r\n\r\n# print(states_to_fit)\r\n# print(t_ve" +
                    "c)\r\n# print(t_vec_new)\r\n\r\n## ##################################### #\r\n## Initial" +
                    " Parameters for 3x3 Matrix ##\r\n \r\nstart_params <- c(0.838, 0.162, 0.00, 0.009, 0" +
                    ".904, 0.087, 0.009, 0.192, 0.799) \r\n\r\n## Read Data from Excel File ####\r\n\r\n# Che" +
                    "ck if the file exists\r\nif (file.exists(path_source_file)) {\r\n  # Read data frame" +
                    " from Excel file\r\n  df_rates <- readxl::read_excel(path_source_file, sheet = exc" +
                    "el_sheet_name_rates)\r\n  df_UCT   <- readxl::read_excel(path_source_file, sheet =" +
                    " excel_sheet_name_uct)\r\n  df_diseasestates_input <- readxl::read_excel(path_sour" +
                    "ce_file, sheet = excel_statesfitting)\r\n  df_remission <- readxl::read_excel(path" +
                    "_source_file, sheet = excel_remission)\r\n} else {\r\n  print(\"Input file not found." +
                    "\") #permission problems or no file\r\n}\r\n\r\n## Print previously read data\r\n# print(" +
                    "df_rates)\r\n# print(df_UCT)\r\n# print(df_diseasestates_input)\r\n# print(df_remissio" +
                    "n)\r\n\r\n# Fit the model using least squares -- #todo different algorithm to python" +
                    "\r\nout <- stats::optim(start_params, residual, method = \"L-BFGS-B\", lower = rep(0" +
                    ", 9), upper = rep(1, 9))\r\n\r\n# opt <- trustOptim::trust.optim(start_params, resid" +
                    "ual, grad, hess, method=\"Sparse\")\r\n\r\n# diseaseprobabilities_fitted is for contro" +
                    "l\r\n# Reshape der 1D-Array in eine 3x3-Matrix\r\n  diseaseprobabilities_fitted <- m" +
                    "atrix(out$par, nrow = 3, ncol = 3, byrow = TRUE)\r\n  \r\n# Normalisierung der Zeile" +
                    "n der Matrix mit der L1-Norm\r\n  diseaseprobabilities_fitted <- t(apply(diseasepr" +
                    "obabilities_fitted, 1, function(row) row / sum(abs(row))))\r\n  \r\n# Anzeige der no" +
                    "rmalisierten Matrix \r\n  print(diseaseprobabilities_fitted)\r\n  \r\n## #############" +
                    "######################### ##\r\n## Export Model and actual Data ##########\r\n## ###" +
                    "################################### ##\r\n    \r\n  readr::write_rds(model_diseasest" +
                    "ates(out$par), file.path(path_data_folder, \"diseasestates_model.rds\"))\r\n  readr:" +
                    ":write_csv(as.data.frame(model_diseasestates(out$par)), file.path(path_data_fold" +
                    "er, \"diseasestates_model.csv\"))\r\n  writexl::write_xlsx(as.data.frame(model_disea" +
                    "sestates(out$par)), file.path(path_data_folder, \"diseasestates_model.xlsx\"))\r\n  " +
                    "\r\n  df_diseasestates_input_df <- as.data.frame(df_diseasestates_input)\r\n  readr:" +
                    ":write_rds(df_diseasestates_input_df, file.path(path_data_folder, \"diseasestates" +
                    "_input.rds\"))\r\n  readr::write_csv(df_diseasestates_input_df, file.path(path_data" +
                    "_folder, \"diseasestates_input.csv\"))\r\n  writexl::write_xlsx(df_diseasestates_inp" +
                    "ut_df, file.path(path_data_folder, \"diseasestates_input.xlsx\"))\r\n\r\n# ###########" +
                    "############################ #\r\n## Plot the model and the actual data ####\r\n# ##" +
                    "##  03_plot_state_probabilities.r #### #\r\n# ####################################" +
                    "### #\r\n\r\n## ####################################################################" +
                    "###### ##  \r\n  \r\n# Calculate and display the fitted disease probabilities\r\n# Pyt" +
                    "hon values for consistency --> #todo Check algorithm \r\n# array([[8.83546195e-01," +
                    " 1.16439063e-01, 1.47418074e-05],\r\n#  [5.21009280e-03, 9.55420736e-01, 3.9369171" +
                    "0e-02],\r\n#  [7.23381020e-03, 7.66933782e-02, 9.16072812e-01]])\r\n  \r\ndiseaseproba" +
                    "bilities_fitted <- prop.table(matrix(out$par, nrow = 3, ncol = 3), margin = 1)\r\n" +
                    "\r\ndiseaseprobabilities_fitted <- matrix(c(0.883546195, 0.116439063, 0.000047418," +
                    "\r\n                                        0.005210092, 0.955420736, 0.039369171," +
                    "\r\n                                        0.007233810, 0.076693378, 0.916072815)" +
                    ", ncol = 3, byrow = TRUE)\r\n\r\n# print(diseaseprobabilities_fitted)\r\n# Convert dat" +
                    "a frames to matrices\r\n\r\nrateMatrix <- as.matrix(df_rates)\r\nUCTMatrix <- as.matri" +
                    "x(df_UCT)\r\nstates <- colnames(rateMatrix)\r\n\r\n###################################" +
                    "##### #\r\n# Define Transition Matrix  ####\r\n#####################################" +
                    "### #\r\n\r\ntime <- 1  # time for rateMatrix in weeks\r\ntransMatrix <- 1 - exp(-rate" +
                    "Matrix / time)\r\ntransMatrix[6:8, 6:8] <- diseaseprobabilities_fitted\r\n\r\n# set di" +
                    "agonal elements to 0 and calculate diagonal elements as 1-(row sum)\r\n\r\ntransMatr" +
                    "ix <- recalculate_main_diagonal(transMatrix)\r\ncheck_matrix_row_sum(transMatrix)\r" +
                    "\n\r\n# Print transition matrix\r\n# Save matrices and states to CSV files\r\n\r\nreadr::" +
                    "write_csv(as.data.frame(rateMatrix), file.path(path_data_folder, \"rateMatrix.csv" +
                    "\")) \r\nreadr::write_csv(as.data.frame(transMatrix), file.path(path_data_folder, \"" +
                    "transMatrix.csv\"))\r\nreadr::write_csv(as.data.frame(states), file.path(path_data_" +
                    "folder, \"states.csv\"))\r\n\r\n#### Silent header? \r\n#### Other types - .xlsx or .rds" +
                    "? --> Rüdiger Excel Export\r\n\r\nprint(round(transMatrix,3))\r\nprint(round(transMatr" +
                    "ix[1:8, 9],3))\r\nprint(states)\r\n\r\n\r\n## ####################################### # " +
                    "\r\n##    Time Evolution and Steady State   #### \r\n## ############################" +
                    "########### # \r\n\r\nremission_prob <- as.matrix(df_remission)\r\nprint(round(df_remi" +
                    "ssion[100,],3))\r\ntransMatrix [1:8, 9] <- remission_prob[100,]\r\nprint(transMatrix" +
                    ")\r\n\r\n\r\n########################################### #\r\n#       Definition of Inte" +
                    "rventions      ####\r\n########################################### #\r\n\r\n# Awarenes" +
                    "s Campaign improves Diagnosis rate by Factor var_diagrate\r\n\r\nvar_diagrate <- 1.4" +
                    "2\r\ntransMatrix_awa1 <- transMatrix  \r\n\r\ntransMatrix_awa1[1, 2] <- transMatrix[1," +
                    " 2] * var_diagrate\r\ntransMatrix_awa1[1, 3] <- transMatrix[1, 3] * var_diagrate\r\n" +
                    "\r\nprint(transMatrix)\r\nprint(transMatrix_awa1)\r\n\r\n# Educational Effect\r\n# KOL dia" +
                    "gnosis program | 36% higher diagnosis rate \r\n\r\ntransMatrix_edu1 <- transMatrix\r\n" +
                    "var_diagratio <- 0.36\r\n\r\ntransMatrix_edu1[1, 2] <- transMatrix[1, 2] + transMatr" +
                    "ix[1, 3] * var_diagratio \r\ntransMatrix_edu1[1, 3] <- transMatrix[1, 3] - transMa" +
                    "trix[1, 3] * var_diagratio\r\n\r\nprint(transMatrix)\r\nprint(transMatrix_edu1)\r\n\r\n# T" +
                    "reatment Effect\r\n# Treatment ratio (DMP)\r\n\r\ntransMatrix_dmp1 <- transMatrix\r\nvar" +
                    "_treatmentratio <- 0.18\r\n\r\ntransMatrix_dmp1[2, 4] <- transMatrix[2, 4] + transMa" +
                    "trix[2, 4] * var_treatmentratio\r\ntransMatrix_dmp1[2, 5] <- transMatrix[2, 5] - t" +
                    "ransMatrix[2, 4] * var_treatmentratio\r\n\r\nprint(transMatrix)\r\nprint(transMatrix_d" +
                    "mp1)\r\n\r\n\r\n# Combined Effect of all inventions\r\n# treatment ratio (all interventi" +
                    "ons)\r\n\r\n\r\ntransMatrix_all1 <- transMatrix\r\n\r\ntransMatrix_all1[1, 2] <- (transMat" +
                    "rix[1, 2] + transMatrix[1, 3] * var_diagratio) * var_diagrate  \r\ntransMatrix_all" +
                    "1[1, 3] <- (transMatrix[1, 3] - transMatrix[1, 3] * var_diagratio) * var_diagrat" +
                    "e  \r\ntransMatrix_all1[2, 4] <- transMatrix[2, 4] + transMatrix[2, 4] * var_treat" +
                    "mentratio  \r\ntransMatrix_all1[2, 5] <- transMatrix[2, 5] - transMatrix[2, 4] * v" +
                    "ar_treatmentratio\r\n\r\nprint(transMatrix)\r\nprint(transMatrix_all1)\r\n\r\n\r\n##########" +
                    "#######################  ##\r\n##    Simulations / Iterations   ####\r\n############" +
                    "##################### ##\r\n\r\nprint(round(transMatrix,3))\r\n\r\ntransMatrix\r\n \r\nstead" +
                    "ystate_statusquo <- get_steadystate(transMatrix)\r\nsteadystate_edu1 <- get_steady" +
                    "state(transMatrix_edu1)\r\nsteadystate_awa1 <- get_steadystate(transMatrix_awa1)\r\n" +
                    "steadystate_dmp1 <- get_steadystate(transMatrix_dmp1)\r\nsteadystate_all1 <- get_s" +
                    "teadystate(transMatrix_all1)\r\n\r\n\r\nsteadystate_statusquo\r\nsteadystate_edu1\r\nstead" +
                    "ystate_awa1\r\nsteadystate_dmp1\r\nsteadystate_all1\r\n\r\n#############################" +
                    "##### #\r\n\r\ncutoff_highUCT <- 12\r\n\r\nreshaped_steadystate_statusquo <- reshape_ste" +
                    "adystate_variables(steadystate_statusquo, states, UCTMatrix, cutoff_highUCT)\r\n\r\n" +
                    "reshaped_steadystate_edu1 <- reshape_steadystate_variables(steadystate_edu1, sta" +
                    "tes, UCTMatrix, cutoff_highUCT)\r\nreshaped_steadystate_awa1 <- reshape_steadystat" +
                    "e_variables(steadystate_awa1, states, UCTMatrix, cutoff_highUCT)\r\nreshaped_stead" +
                    "ystate_dmp1 <- reshape_steadystate_variables(steadystate_dmp1, states, UCTMatrix" +
                    ", cutoff_highUCT)\r\nreshaped_steadystate_all1 <- reshape_steadystate_variables(st" +
                    "eadystate_all1, states, UCTMatrix, cutoff_highUCT)\r\n\r\n\r\n\r\n#todo wegspeichern\r\n\r\n" +
                    "#transMatrix_awa2 <- recalculate_main_diagonal(transMatrix_awa1)\r\n#check_matrix_" +
                    "row_sum (transMatrix_awa2)\r\n\r\nreshaped_steadystate_statusquo\r\nreshaped_steadysta" +
                    "te_edu1\r\nreshaped_steadystate_awa1\r\nreshaped_steadystate_dmp1\r\nreshaped_steadyst" +
                    "ate_all1\r\n\r\n\r\n################################## #\r\n#           Plotting        " +
                    "   ### #\r\n################################## #\r\n\r\n# Barplot erstellen\r\n\r\npar(mar" +
                    "=c(3, 9, 2, 1) + 3)\r\nbarplot(\r\n  t(reshaped_steadystate_statusquo$aggregated_sta" +
                    "tes_df),  # Transponieren der Daten für die richtige Anordnung\r\n  beside = TRUE," +
                    "           # Gruppierte Balken nebeneinander\r\n  col = rainbow(5),        # Farbe" +
                    "n für die Balken\r\n  col.axis = \"darkblue\",\r\n  col.main = \"darkblue\",\r\n#  col.lab" +
                    " = \"darkblue\",\r\n  names.arg = colnames(reshaped_steadystate_statusquo$aggregated" +
                    "_states_df),  # Beschriftung der x-Achse\r\n  main = \"Steady-State Status Quo\",  #" +
                    " Titel des Diagramms\r\n  ylab = \"\",las =1,       # Beschriftung der x-Achse\r\n  xl" +
                    "ab = \"Share\",         # Beschriftung der y-Achse\r\n  horiz = TRUE,\r\n#  legend.tex" +
                    "t = colnames(reshaped_steadystate_statusquo$aggregated_states_df),  # Legendenbe" +
                    "schriftung\r\n # args.legend = list(x = \"topright\")  # Legendenposition\r\n)\r\n\r\n\r\n\r\n" +
                    "");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    public class RuntimeRCodeTemplateBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        public System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
